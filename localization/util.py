import math
import numpy

class StateMember:
    """Enumeration of all members of the observed state.

    Stores indexes for each coordinate of the observed state. Coordinates are
    stored in groups of 3 and are:
    * Position in World frame
    * Orientation in World frame, given in RPY
    * Linear velocity in Local frame
    * Angular velocity in Local frame
    * Linear acceleration in Local frame

    Overall count sums up to 15 state coordinates.
    """
    x = 0
    y = 1
    z = 2
    roll = 3
    pitch = 4
    yaw = 5
    v_x = 6
    v_y = 7
    v_z = 8
    v_roll = 9
    v_pitch = 10
    v_yaw = 11
    a_x = 12
    a_y = 13
    a_z = 14


def clampRotation(angle):
    """Reduce any angle in radians back to the [-pi, pi] range.

    Parameters
    ----------
    angle: float
        Unclamped angle in radians

    Returns
    -------
    float
        Angle within the [-pi, pi] range

    Examples
    --------
    >>> clampRotation(7)
    0.7168146928204138
    """
    while (angle > math.pi):
        angle -= 2.0 * math.pi
    while (angle < -math.pi):
        angle += 2.0 * math.pi
    return angle


def rpyToRotationMatrix(roll, pitch, yaw):
    """Generate rotation matrix based on RPY angles.

    Matrix is generated by chaining yaw -> pitch -> roll rotations.

    Parameters
    ----------
    roll: float
        Rotation around x axis
    pitch: float
        Rotation around y axis
    yaw: float
        Rotation around z axis

    Returns
    -------
    numpy.ndarray
        Rotation matrix, 3x3 size

    Examples
    --------
    >>> from math import pi
    >>> rpyToRotationMatrix(pi / 4., pi / 4., pi)
    array([[ -7.07106781e-01,  -5.00000000e-01,  -5.00000000e-01],
           [  8.65956056e-17,  -7.07106781e-01,   7.07106781e-01],
           [ -7.07106781e-01,   5.00000000e-01,   5.00000000e-01]])
    """
    trig_funcs = (math.cos(roll), math.cos(pitch), math.cos(yaw),
                  math.sin(roll), math.sin(pitch), math.sin(yaw))
    return __sinCosToRotationMatrix(*trig_funcs)


def rpyToRotationMatrixAndDerivatives(roll, pitch, yaw):
    """Generate rotation matrix and derivatives around each of the RPY angles.

    Matrix is generated by chaining yaw -> pitch -> roll rotations.
    Results are returned as a tuple.

    Parameters
    ----------
    roll: float
        Rotation around x axis
    pitch: float
        Rotation around y axis
    yaw: float
        Rotation around z axis

    Returns
    -------
    R: numpy.ndarray
        Rotation matrix, 3x3 size
    dR_dRoll: numpy.ndarray
        Rotation matrix R derived by roll parameter
    dR_dPitch: numpy.ndarray
        Rotation matrix R derived by pitch parameter
    dR_dYaw: numpy.ndarray
        Rotation matrix R derived by yaw parameter

    Examples
    --------
    >>> from math import pi
    >>> R, dr, dp, dy = rpyToRotationMatrixAndDerivatives(pi / 4., pi / 4., pi)
    """
    trig_funcs = (math.cos(roll), math.cos(pitch), math.cos(yaw),
                  math.sin(roll), math.sin(pitch), math.sin(yaw))
    return (__sinCosToRotationMatrix(*trig_funcs),
            __sinCosToRdr(*trig_funcs),
            __sinCosToRdp(*trig_funcs),
            __sinCosToRdy(*trig_funcs))


def __sinCosToRotationMatrix(cr, cp, cy, sr, sp, sy):
    """Helper function for generating the rotation matrix."""
    return numpy.array([
            [cy * cp, cy * sp * sr - sy * cr, cy * sp * cr + sy * sr],
            [sy * cp, sy * sp * sr + cy * cr, sy * sp * cr - cy * sr],
            [-sp, cp * sr, cp * cr]])


def __sinCosToRdr(cr, cp, cy, sr, sp, sy):
    """Helper function for generating the rotation matrix roll derivative."""
    return numpy.array([[
            0.,
            cy * sp * cr + sy * sr,
            -cy * sp * sr + sy * cr,
        ], [
            0.,
            sy * sp * cr - cy * sr,
            -sy * sp * sr - cy * cr,
        ], [
            0.,
            cp * cr,
            -cp * sr,
        ]])


def __sinCosToRdp(cr, cp, cy, sr, sp, sy):
    """Helper function for generating the rotation matrix pitch derivative."""
    return numpy.array([[
            -cy * sp,
            cy * cp * sr,
            cy * cp * cr,
        ], [
            -sy * sp,
            sy * cp * sr,
            sy * cp * cr,
        ], [
            -cp,
            -sp * sr,
            -sp * cr,
        ]])


def __sinCosToRdy(cr, cp, cy, sr, sp, sy):
    """Helper function for generating the rotation matrix yaw derivative."""
    return numpy.array([[
            -sy * cp,
            -sy * sp * sr - cy * cr,
            -sy * sp * cr + cy * sr,
        ], [
            cy * cp,
            cy * sp * sr - sy * cr,
            cy * sp * cr + sy * sr,
        ], [
            0.,
            0.,
            0.,
        ]])


class Measurement(object):
    """Structure for storing measurements.

    Parameters
    ----------
    time: float
        Time since simulation start, in seconds
    measurement: numpy.ndarray
        Measured value of observed states. Size is Nx1
    covariance: numpy.ndarray
        Covariance matrix of the measurement. Size is NxN
    update_vector: list(StateMember)
        List or tuple of N state members that represent the current state.

    Attributes
    ----------
    time
    measurement
    covariance
    update_vector
    mahalanobis_threshold: float
        Threshold for the Mahalanobis distance.

    Examples
    --------
    Create a measurement of velocities.
    We measured forward movement of 0.2 m/s, 10.2s after simulation start.
    >>> import numpy
    >>> m = numpy.array([0.2, 0., 0.]).reshape([3,1])
    >>> c = numpy.diag([0.1, 0.1, 0.1])
    >>> update_vector = [StateMember.v_x, StateMember.v_y, StateMember.v_z]
    >>> Measurement(10.2, m, c, update_vector)
    """
    def __init__(self, time, measurement, covariance, update_vector):
        super(Measurement, self).__init__()
        self.measurement = measurement
        self.covariance = covariance
        self.update_vector = update_vector
        self.time = time
        self.mahalanobis_threshold = float('inf')

    def __cmp__(self, other):
        """Compare measurement by comparing their timestamps."""
        return cmp(self.time, other.time)
